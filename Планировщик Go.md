- Для переключения между потоками операционной системы необходимо менять контекст, это ресурсозатратная операция. 
- Горутины имеют свои регистры, свой стек и свой контекст, про который не знает операционная система. Чтобы переключаться между горутинами, нам не нужно менять контекст, все происходит на уровне user контекста.
- Один поток операционной системы ~ 2-4-8 мб. Одна горутинка от 2 кб. Поэтому мы можем выделять под каждое соединение отдельную горутину. Для 10000 соединений необходимо 20 мб оперативной памяти. В одном потоке может быть максимум 256 горутин.

- У каждого потока операционной системы есть локальная очередь с горутинами, которые выполняются последовательно. Горутины имеют кооперативную многозадачность, то есть невытесняющий алгоритм. На этапе проверки - достаточно ли памяти горутине, мы проверяем нужно ли менять контекст на контекст новой горутины (выполнять новую горутину).![[scheduler.png]]
- Поток, у которого закончились горутины, крадет горутины у других потоков. Потоки выбираются случайно и стучать в другие потоки можно 4 раза. Крадем из другого потока половину горутин, чтобы слишком часто не ходить по потокам.

- Если поток берет горутину, которая выполняет I/O операцию, то необходимо сделать системный вызов, который сменит контекст. Этот системный вызов блокирует поток на какое-то время. 
- Если он блокирует его на большое количество времени, то специальный поток sysmon открепляет поток от очереди, помещает его в пул потоков (с состаянием выполнения) и создает новый поток для этой очереди, либо берет для этой горутины свободный поток из тред пула. Если системный вызов ненадолго блокирует поток (short-lived syscalls), то поток sysmon переодически проверяет, ожил ли поток. Если этот поток через какое-то время не ожил, то мы его открепим от очереди и поместим в тред пул (с состоянием выполнения) и отдадим новый поток для этой очереди.![[scheduler1.png]]![[scheduler3.png]]

- Когда выполнился системный вызов, нам нужно вернуть горутину в ту же самую очередь. Если у нас это не получается, очередь заполнена или в ней выполняется системный вызов, то мы добавляем горутину в глобальную очередь.![[scheduler4.png]]

- Netpoller - это аналог Event Loop, блокирующие сетевые запросы на запись/чтение отправляются в этот поток, вместо того чтобы создавать отдельный поток под каждый блокирующий запрос. Когда поток выполнит какой-либо запрос (сетевой вызов), он отправит горутину в ту очередь,  откуда она послупила, если очередь не переполнена и не заблокирована.![[scheduler5.png]]

- В рантайме планировщика каждый 1/61 тик (один раз за 61 обращение к планировщику) мы проверяем глобальную очередь. В других случаях, если мы не нашли горутины в локальных очередях, то идем в глобальную очередь, если в глобальной очереди ничего нет, то ждем данных от сети.

- Горутины как и потоки имеют три состояния, готовы к выполнению, выполнение, ожидание. Чтобы не блокировать весь поток, который будет ждать, пока выполнится системный вызов и не отцеплять целый поток с горутиной в тред пул, можно заблокировать горутину c помощью мьютекса на уровне горутин и при этом не блокировать поток, после чего отправить горутину в очередь ожидания. Далее новая неблокирующая горутина захватывает мьютекс и выполняется. 
- Все что связано с примитивами синхронизации отправляется в очередь ожидания для горутин. Все что связано с системными вызовами, поток с горутиной открепляются от очереди и идут в тред пул.
- В режиме голодания, после завершения горутины, она сразу передает мьютекс горутине из очереди ожидания и та захватывает мьютекс, в случае долгого ожидания![[scheduler6.png]]

- Если мы посадили бесконечные циклы для того, чтобы обрабатывать CPU Bound нагрузку, тот поток sysmon, если горутина работает больше чем 10мс, отправляет сигнал на вытеснение этой горутины асинхронно в сейф поинте.